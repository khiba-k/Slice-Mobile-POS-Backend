generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// User and Store Models

model User {
  id                String   @id @default(cuid())
  userId            String   @unique
  firstName         String
  lastName          String
  idNumber          String   @unique
  email             String   @unique
  dateOfBirth       DateTime
  primaryPhoneNum   String
  secondaryPhoneNum String?
  isOwner           Boolean  @default(false)

  // Relations
  storeId        String?
  store          Store?  @relation(fields: [storeId], references: [id])
  salesAsCashier Sale[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Store {
  id       String @id @default(cuid())
  name     String
  industry String
  location String
  district String
  country  String

  // Relations
  users               User[]
  items               Item[]
  itemTypeDepartments ItemTypeDepartment[]
  sales               Sale[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Inventory Models

model Item {
  id             String  @id @default(cuid())
  itemNumber     String  @unique
  itemType       String
  departmentName String
  name           String
  description    String?

  unitSize String?
  unitType String?

  qtyAvailable     Int  @default(0) // actual stock available
  reservedQty      Int  @default(0) // quantity reserved by draft sales
  lowStockAlertQty Int?

  sellingPrice     Float
  costPrice        Float?
  markupPercentage Float?

  // Relations
  storeId   String
  store     Store       @relation(fields: [storeId], references: [id])
  images    ItemImage[]
  saleItems SaleItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ItemImage {
  id             String  @id @default(cuid())
  url            String
  itemId         String
  isDisplayImage Boolean @default(false)

  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)
}

model ItemTypeDepartment {
  id             String @id @default(cuid())
  itemType       String
  departmentName String

  // Optional store scope (so each store can have its own combos)
  storeId String
  store   Store  @relation(fields: [storeId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([itemType, departmentName, storeId])
}

// Sales Models
enum SaleStatus {
  DRAFT
  COMPLETED
  REVERSED
}

enum PaymentMethod {
  CASH
  MPESA
  ECOCASH
  CARD
}

model Sale {
  id         String  @id @default(cuid())
  name       String?
  saleNumber String  @unique

  // Relations
  storeId String
  store   Store  @relation(fields: [storeId], references: [id])

  cashierId   String?
  cashier     User?   @relation(fields: [cashierId], references: [id], onDelete: SetNull)
  cashierName String

  saleItems SaleItem[]

  paymentMethod  PaymentMethod?
  subtotal       Float
  discountAmount Float?        @default(0)
  total          Float

  status SaleStatus @default(DRAFT)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model SaleItem {
  id     String @id @default(cuid())
  saleId String
  sale   Sale   @relation(fields: [saleId], references: [id], onDelete: Cascade)

  itemId   String?
  item     Item?   @relation(fields: [itemId], references: [id], onDelete: SetNull)
  itemName String

  quantity  Int
  unitPrice Float
  subtotal  Float
}
